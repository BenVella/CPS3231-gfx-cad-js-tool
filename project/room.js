Room.WALL_TYPE = {
    EMPTY: 0,
    SOLID: 1,
    DOOR: 2,
    WINDOW: 3
}

Room.wallTypeToString = function (typeVal) {
    switch (typeVal) {
        case Room.WALL_TYPE.EMPTY:
            return 'EMPTY';
        case Room.WALL_TYPE.SOLID:
            return 'SOLID';
        case Room.WALL_TYPE.DOOR:
            return 'DOOR';
        case Room.WALL_TYPE.WINDOW:
            return 'WINDOW';
        default:
            return 'unclassified';
    }
}
/**
 * Creates a room, holds various parameters and generates model geometry.
 * A Call to build() is necessary to construct any visible geometry which is then bound to scene.
 * @param {*} id Generated by Map and passed as identifier
 * @param {*} name Name given by user, optional or forced depending on html
 * @param {*} width Width of room, restrained by pre-existing neighbours
 * @param {*} breadth Breadth of room, restrained by pre-existing neighbours
 * @param {*} material A dictionary containing floor, ceiling and wall names from textures.js properties.
 *                      Null results in no geometry being created for that category.
 */
function Room(id, name, width, breadth, chosenMaterials, position) {
    this.id = id;
    this.width = width;
    this.breadth = breadth;
    this.position = position;
    this.name = name;
    this.reference = this.id + '_' + this.name;
    // Position stores bottom left corner of each room for x and z locations.  Our assumption is x grows to the right.

    this.buildCeiling = false; // If true, ceilings will be constructed.
    this.isMain = false; // Primary room - placed first in map.
    this.isFull = false; // All neighbours are present.

    this.materials = {
        floor: chosenMaterials.floor, ceiling: chosenMaterials.ceiling,
        walls: {
            north: chosenMaterials.walls.north, east: chosenMaterials.walls.east,
            south: chosenMaterials.walls.south, west: chosenMaterials.walls.west
        }
    };

    this.wallsType = {
        north: Room.WALL_TYPE.SOLID,
        east: Room.WALL_TYPE.SOLID,
        south: Room.WALL_TYPE.SOLID,
        west: Room.WALL_TYPE.SOLID
    };

    /** Adjacency List functionality of neighbours */
    this.neighbours = { north: null, east: null, south: null, west: null };
    /** Model reference, also present in sceneNodes.entry.nodeObject */
    this.models = { floor: null, ceiling: null, walls: { north: null, east: null, south: null, west: null } };
    /** These contain the actual data to be rendered in view */
    this.sceneNodes = { room: null, floor: null, ceiling: null, walls: { north: null, east: null, south: null, west: null } }
    /** Store size of window or doorway to be used in construction */
    this.openingSize = { north: null, east: null, south: null, west: null }
    /** Stores general location of opening - door or window */
    this.openingOffset = { north: undefined, east: undefined, south: undefined, west: undefined }

    /** Objects created for a room are tracked in here 
     * Each Object is a series of room Objects with {int id Key : RoomObject } */
    this.objectCount = 0;
    this.objectList = {};
}

//--------------------------------------------------------------------------------------------------------//
// Geometric Construction
//--------------------------------------------------------------------------------------------------------//

/** Called to construct the room's geometry based on provided parameters. */
Room.prototype.build = function () {
    if (this.sceneNodes.room === null)
        this.sceneNodes.room = scene.addNode(lightNode, null, this.id + "_ROOM", Node.NODE_TYPE.GROUP);

    // Builds quads -> models -> scene objects
    this.generateGeometry();
    // Attaches materials to each model for rendering
    this.attachMaterials();

    matrixHelper.matrix4.makeTranslation(this.sceneNodes.room.transform, this.position);
}

/** Builds 3d geometry of floor, walls and optionally ceiling */
Room.prototype.generateGeometry = function () {
    /** FlOOR */
    if (this.materials.floor !== null) {
        const floorCuboid = geobuilder.createFloor(this.width, this.breadth);
        this.models.floor = this.buildModel(floorCuboid, "floor");
        // Add to scene and move it west of room
        if (this.sceneNodes.floor !== null)
            this.sceneNodes.floor.nodeObject = this.models.floor;
        else
            this.sceneNodes.floor = scene.addNode(this.sceneNodes.room, this.models.floor, this.reference + "floor", Node.NODE_TYPE.MODEL);

        matrixHelper.matrix4.makeTranslation(this.sceneNodes.floor.transform, [0, -Geometry.DIMENSIONS.floorHeight + Number.EPSILON, 0]);
    }

    /** CEILING */
    if (this.buildCeiling && this.materials.ceiling !== null) {
        /** Floor currently expands to support walls underneath, we will create a simple cuboid here. */
        const ceilingCuboid = geobuilder.createCuboid(this.width, this.breadth, Geometry.DIMENSIONS.floorHeight);
        this.models.ceiling = this.buildModel(ceilingCuboid, "ceiling");
        // Add ceiling to scene and move it up to room height - floor thickness
        if (this.sceneNodes.ceiling !== null)
            this.sceneNodes.ceiling.nodeObject = this.models.ceiling;
        else
            this.sceneNodes.ceiling = scene.addNode(this.sceneNodes.room, this.models.ceiling, this.reference + "ceiling", Node.NODE_TYPE.MODEL);

        matrixHelper.matrix4.makeTranslation(this.sceneNodes.ceiling.transform, [0, Geometry.DIMENSIONS.roomHeight - Geometry.DIMENSIONS.floorHeight, 0]);
    }

    /** NORTH WALL */
    if (this.materials.walls.north !== null) {
        let wallNorthCuboid = null;
        if (this.wallsType.north === Room.WALL_TYPE.SOLID) wallNorthCuboid = geobuilder.createFrontWall(this.width);
        else if (this.wallsType.north === Room.WALL_TYPE.DOOR) wallNorthCuboid = geobuilder.createFrontDoorway(this.width, this.openingSize.north, this.openingOffset.north);
        else if (this.wallsType.north === Room.WALL_TYPE.WINDOW) wallNorthCuboid = geobuilder.createFrontWindow(this.width, this.openingSize.north, this.openingOffset.north);
        this.models.walls.north = this.buildModel(wallNorthCuboid, "northWall");
        // Add to scene and move it north of room
        if (this.sceneNodes.walls.north !== null)
            this.sceneNodes.walls.north.nodeObject = this.models.walls.north;
        else
            this.sceneNodes.walls.north = scene.addNode(this.sceneNodes.room, this.models.walls.north, this.reference + "northWall", Node.NODE_TYPE.MODEL);

        matrixHelper.matrix4.makeTranslation(this.sceneNodes.walls.north.transform, [0, 0, ((this.breadth / 2) + (Geometry.DIMENSIONS.wallThickness / 2)) * Map.DIRECTION.north[1]]);
    }
    /** EAST WALL */
    if (this.materials.walls.east !== null) {
        let wallEastCuboid = null;
        if (this.wallsType.east === Room.WALL_TYPE.SOLID) wallEastCuboid = geobuilder.createSideWall(this.breadth);
        else if (this.wallsType.east === Room.WALL_TYPE.DOOR) wallEastCuboid = geobuilder.createSideDoorway(this.breadth, this.openingSize.east, this.openingOffset.east);
        else if (this.wallsType.east === Room.WALL_TYPE.WINDOW) wallEastCuboid = geobuilder.createSideWindow(this.breadth, this.openingSize.east, this.openingOffset.east);
        this.models.walls.east = this.buildModel(wallEastCuboid, "eastWall");
        // Add to scene and move it east of room
        if (this.sceneNodes.walls.east !== null)
            this.sceneNodes.walls.east.nodeObject = this.models.walls.east;
        else
            this.sceneNodes.walls.east = scene.addNode(this.sceneNodes.room, this.models.walls.east, this.reference + "eastWall", Node.NODE_TYPE.MODEL);

        matrixHelper.matrix4.makeTranslation(this.sceneNodes.walls.east.transform, [((this.width / 2) + (Geometry.DIMENSIONS.wallThickness / 2)) * Map.DIRECTION.east[0], 0, 0]);
    }
    /** SOUTH WALL */
    if (this.materials.walls.south !== null) {
        let wallSouthCuboid = null;
        if (this.wallsType.south === Room.WALL_TYPE.SOLID) wallSouthCuboid = geobuilder.createFrontWall(this.width);
        else if (this.wallsType.south === Room.WALL_TYPE.DOOR) wallSouthCuboid = geobuilder.createFrontDoorway(this.width, this.openingSize.south, this.openingOffset.south);
        else if (this.wallsType.south === Room.WALL_TYPE.WINDOW) wallSouthCuboid = geobuilder.createFrontWindow(this.width, this.openingSize.south, this.openingOffset.south);
        this.models.walls.south = this.buildModel(wallSouthCuboid, "southWall");
        // Add to scene and move it south of room
        if (this.sceneNodes.walls.south !== null)
            this.sceneNodes.walls.south.nodeObject = this.models.walls.south;
        else
            this.sceneNodes.walls.south = scene.addNode(this.sceneNodes.room, this.models.walls.south, this.reference + "southWall", Node.NODE_TYPE.MODEL);

        matrixHelper.matrix4.makeTranslation(this.sceneNodes.walls.south.transform, [0, 0, ((this.breadth / 2) + (Geometry.DIMENSIONS.wallThickness / 2)) * Map.DIRECTION.south[1]]);
    }
    /** WEST WALL */
    if (this.materials.walls.west !== null) {
        let wallWestCuboid = null;
        if (this.wallsType.west === Room.WALL_TYPE.SOLID) wallWestCuboid = geobuilder.createSideWall(this.breadth);
        else if (this.wallsType.west === Room.WALL_TYPE.DOOR) wallWestCuboid = geobuilder.createSideDoorway(this.breadth, this.openingSize.west, this.openingOffset.west);
        else if (this.wallsType.west === Room.WALL_TYPE.WINDOW) wallWestCuboid = geobuilder.createSideWindow(this.breadth, this.openingSize.west, this.openingOffset.west);
        this.models.walls.west = this.buildModel(wallWestCuboid, "westWall");
        // Add to scene and move it west of room
        if (this.sceneNodes.walls.west !== null)
            this.sceneNodes.walls.west.nodeObject = this.models.walls.west;
        else
            this.sceneNodes.walls.west = scene.addNode(this.sceneNodes.room, this.models.walls.west, this.reference + "westWall", Node.NODE_TYPE.MODEL);

        matrixHelper.matrix4.makeTranslation(this.sceneNodes.walls.west.transform, [((this.width / 2) + (Geometry.DIMENSIONS.wallThickness / 2)) * Map.DIRECTION.west[0], 0, 0]);
    }
}

/** Construct model to be bound to scene node */
Room.prototype.buildModel = function (cuboid, identifier) {
    const newModel = new Model();
    newModel.name = identifier;
    newModel.index = cuboid.index;
    newModel.vertex = cuboid.vertex;
    newModel.compile(scene);

    return newModel;
}

/** Attaches all available materials to all available models */
Room.prototype.attachMaterials = function () {
    if (this.materials.floor !== null && this.models.floor !== null)
        this.models.floor.material = buildBasicMaterial(this.materials.floor);
    if (this.materials.ceiling !== null && this.models.ceiling !== null)
        this.models.ceiling.material = buildBasicMaterial(this.materials.ceiling);

    const dirs = ['west', 'east', 'north', 'south'];
    for (const dir of dirs) {
        if (this.materials.walls[dir] !== null && this.models.walls[dir] !== null)
            this.models.walls[dir].material = buildBasicMaterial(this.materials.walls[dir]);
    }
};

/** Returns a dictionary with {min: vector3, max:vector3} indicating bounds */
Room.prototype.getRoomBounds = function () {
    const halfWidth = this.width / 2;
    const halfBreadth = this.breadth / 2;
    return {
        min: matrixHelper.vector3.from(this.position[0] - halfWidth, 0, this.position[2] - halfBreadth),
        max: matrixHelper.vector3.from(this.position[0] + halfWidth, Geometry.DIMENSIONS.roomHeight, this.position[2] + halfBreadth)
    };
}

/** Returns a list of colliders for doorways */
Room.prototype.getDoorwayColliders = function () {
    const result = [];
    for (const doorDirection of this.getDoorWalls()) {
        let doorGeo = null;
        let offsetPosition = null;
        if (doorDirection === 'north') {
            doorGeo = Geometry.getFrontDoorOpening(this.width, this.openingSize[doorDirection], this.openingOffset[doorDirection]);
            offsetPosition = [0, 0, ((this.breadth / 2) + (Geometry.DIMENSIONS.wallThickness / 2)) * Map.DIRECTION.north[1]];
        } else if (doorDirection === 'south') {
            doorGeo = Geometry.getFrontDoorOpening(this.width, this.openingSize[doorDirection], this.openingOffset[doorDirection]);
            offsetPosition = [0, 0, ((this.breadth / 2) + (Geometry.DIMENSIONS.wallThickness / 2)) * Map.DIRECTION.south[1]];
        } else if (doorDirection === 'west') {
            doorGeo = Geometry.getSideDoorOpening(this.breadth, this.openingSize[doorDirection], this.openingOffset[doorDirection]);
            offsetPosition = [((this.width / 2) + (Geometry.DIMENSIONS.wallThickness / 2)) * Map.DIRECTION.west[0], 0, 0];
        } else { // east
            doorGeo = Geometry.getSideDoorOpening(this.breadth, this.openingSize[doorDirection], this.openingOffset[doorDirection]);
            offsetPosition = [((this.width / 2) + (Geometry.DIMENSIONS.wallThickness / 2)) * Map.DIRECTION.east[0], 0, 0];
        }

        const doorModel = this.buildModel(doorGeo, "tempDoor");
        let doorCollider = Collision.getLocalObjectColliderBounds(doorModel);
        doorCollider = Collision.getOffsetObjectCollider(doorCollider, offsetPosition); // Cardinal
        doorCollider = Collision.getOffsetObjectCollider(doorCollider, this.position); // Room in Map
        result.push(doorCollider);
    }
    return result;
}

/** Creates an object and adds to its own scene */
Room.prototype.createObject = function (name, position) {
    if (objectManager.objectsCatalogue[name] === undefined || objectManager.objectsCatalogue[name] === null)
        throw (`Requested object with name ${name} was not found in objects catalogue.`);

    /** Let's attempt to create the object */
    this.objectCount += 1;
        newObject = new RoomObject(this.objectCount, name, this, position);
    if (newObject && newObject.sceneNode.nodeObject !== null)
        this.objectList[this.objectCount] = newObject
    else {
        this.objectCount -= 1;
        for (const objKey in this.objectList) {
            if (this.objectList[objKey].sceneNode.nodeObject === null) {
                delete this.objectList[objKey];
            }
        }
        throw (`Unable to create object.  Check bounds and other potential colliding objects.`);
    }
}

/** Modifies a given object by setting its scale, translation and rotation
 * TODO- Check if modification causes overlap
 * TODO - Scale, Rotate and Translate the position
 */
Room.prototype.modifyObject = function (objectId, newScale, newTranslate, rotationAngle) {
    const objRef = this.objectList[objectId];

    objRef.setScaling(newScale, true);
    objRef.setRotation(Number(rotationAngle), true);
    objRef.setPosition(newTranslate, true);

//     const originalPosition = objRef.getPosition(); // Store original position
//     const objCenter = matrixHelper.vector3.create();
//     objCenter[1] = originalPosition[1]; // Keep Y as is
//     matrixHelper.vector3.neg(objCenter, Collision.getColliderCenter(objRef.getCollider()));


//     const objTransform = objRef.sceneNode.transform;

//     // Translate object center to 0,0,0
//     const centerMtx = matrixHelper.matrix4.create();
//     matrixHelper.matrix4.makeTranslation(centerMtx, objCenter);
//     matrixHelper.matrix4.multiply(objTransform, objTransform, centerMtx);

//     // Scale
//     const sclMtx = matrixHelper.matrix4.create();
//     matrixHelper.matrix4.makeScaling(sclMtx, newScale);
//     matrixHelper.matrix4.multiply(objTransform, objTransform, sclMtx);

//     // Rotate
//     const rotMtx = matrixHelper.matrix4.create();
//     matrixHelper.matrix4.makeRotationY(rotMtx, Math.radians(rotationAngle));
//     matrixHelper.matrix4.multiply(objTransform, objTransform, rotMtx);

//     // Reverse Centering
//     matrixHelper.vector3.neg(objCenter, objCenter);
//     matrixHelper.matrix4.makeTranslation(centerMtx, objCenter);
//     matrixHelper.matrix4.multiply(objTransform, objTransform, centerMtx);

//     // Translate to given point
//     const trsltMtx = matrixHelper.matrix4.create();
//     matrixHelper.matrix4.makeTranslation(trsltMtx, newTranslate);
//     matrixHelper.matrix4.multiply(objTransform, objTransform, trsltMtx); // Apply translation
}


/** Helper to provide a simple objectId and new position to act upon */
Room.prototype.translateObject = function (objectId, position) {
    // matrixHelper.matrix4.makeTranslation(this.objectList[objectId].sceneNode.transform, position);
    this.objectList[objectId].setPosition(position, true);
}

Room.prototype.scaleObject = function (objectId, scale) {
    // matrixHelper.matrix4.makeScaling(this.objectList[objectId].sceneNode.transform, position);
    this.objectList[objectId].setScaling(scale, true);
}

/** Helper to rotate object */
Room.prototype.rotateObjectY = function (objectId, theta) {
    // const rotatedMatrix = matrixHelper.matrix4.create();
    // matrixHelper.matrix4.makeRotationY(rotatedMatrix, matrixHelper.matrix4.identity, position);
    // matrixHelper.matrix4.multiply(this.objectList[objectId].sceneNode.transform, this.objectList[objectId].sceneNode.transform, rotatedMatrix);
    this.objectList[objectId].setRotation(theta, true);
}

/** Returns a description of objects tied to room 
 * @returns {dictionary} Dict of Dicts.  Containing id and a value of name and scene node dictionary element.
 **/
Room.prototype.getActiveObjectsList = function () {
    return this.objectList;
}
//--------------------------------------------------------------------------------------------------------//
// Helpers
//--------------------------------------------------------------------------------------------------------//

/** Returns a list of room objects of occupied neighbour plots */
Room.prototype.getNeighbours = function () {
    const neighbourResult = [];

    for (const key in this.neighbours) {
        if (Object.hasOwnProperty.call(this.neighbours, key)) {
            const neighbour = this.neighbours[key];
            if (neighbour !== null) {
                neighbourResult.push(neighbour);
            }
        }
    }

    return neighbourResult;
}

Room.prototype.hasNeighbour = function (direction) {
    return this.neighbours[direction] !== null;
}

Room.prototype.isSolidAllowed = function (direction) {
    return this.isDoorUnecessary(direction);
}

/** Returns true if given direction accepts a door */
Room.prototype.isDoorAllowed = function (direction) {
    if (!this.hasNeighbour(direction))
        return false;

    return true;
}

/** Returns if a window can be set on this wall */
Room.prototype.isWindowAllowed = function (direction) {
    if (this.hasNeighbour(direction))
        return false;

    return true;
}

/** Returns true if no door, or there is but may be removed. */
Room.prototype.isDoorUnecessary = function (direction, checkThis = true) {
    if (this.neighbours[direction] === null || this.wallsType[direction] !== Room.WALL_TYPE.DOOR)
        return true;

    const connectedNeighbour = this.neighbours[direction];
    // Check if we can still go to root without neighbour
    if ((checkThis && !this.pathToRootWithout(connectedNeighbour)) ||
        // Check if neighbour can still go to root without us
        !connectedNeighbour.pathToRootWithout(this))
        return false;

    // Both us and our relevant neighbour can make it to root without one another
    return true;
}

Room.prototype.canBeMoved = function () {
    if (this.isMain) return false;
    for (const direction of this.getDoorWalls()) {
        if (!this.isDoorUnecessary(direction, false)) return false;
    }
    return true;
}

/** Return a list of strings indicating which plots are available */
Room.prototype.getFreePlotDirections = function () {
    const directionResult = [];

    for (const key in this.neighbours) {
        if (Object.hasOwnProperty.call(this.neighbours, key)) {
            const neighbour = this.neighbours[key];
            if (neighbour === null) {
                directionResult.push(key);
            }
        }
    }

    return directionResult;
}

/** Return a list of strings indicating which plots are available */
Room.prototype.getNeighbourDirections = function () {
    const directionResult = [];

    for (const key in this.neighbours) {
        if (Object.hasOwnProperty.call(this.neighbours, key)) {
            const neighbour = this.neighbours[key];
            if (neighbour !== null) {
                directionResult.push(key);
            }
        }
    }

    return directionResult;
}

/** Returns a list of solid walls with or without neighbours
 * Useful when looking for door candidates (with neighbours)
 * or window candidates (without neighbours)
 */
Room.prototype.getSolidWalls = function (hasNeighbours) {
    const wallResult = [];
    for (const direction in this.neighbours) { // For every direction
        if ((hasNeighbours && this.neighbours[direction] !== null) || // When neighbours are wanted
            (!hasNeighbours && this.neighbours[direction] === null)) { // When they're not
            if (this.wallsType[direction] === Room.WALL_TYPE.SOLID)
                wallResult.push(direction);
        }
    }
    return wallResult;
}

/** Returns a list of walls which contain a door */
Room.prototype.getDoorWalls = function () {
    const typeResult = [];
    for (const direction in this.neighbours) { // For every direction
        if (this.wallsType[direction] === Room.WALL_TYPE.DOOR)
            typeResult.push(direction);
    }
    return typeResult;
}


/** Returns a dictionary of wall direction and desecription of wall */
Room.prototype.getDescriptiveWalls = function () {
    const wallList = [];
    for (const wall in this.wallsType) {
        if (this.wallsType[wall] !== Room.WALL_TYPE.EMPTY) {
            wallList.push({
                // Used as value
                direction: wall,
                // Used as textContent
                description: `${wall} | ${Room.wallTypeToString(this.wallsType[wall])} | ${this.materials.walls[wall]}`
            });
        }
    }

    return wallList;
}

/** Return a list of strings indicating which plots are available */
Room.prototype.getFreePlotsLength = function () {
    let lengthResult = 0;

    for (const key in this.neighbours) {
        if (Object.hasOwnProperty.call(this.neighbours, key)) {
            const neighbour = this.neighbours[key];
            if (neighbour === null) {
                lengthResult += 1;
            }
        }
    }

    return lengthResult;
}

/** Check if this room still has access to root without a given room */
Room.prototype.pathToRootWithout = function (roomToRemove) {
    // Trivial Success if we're root
    if (this.isMain) return true;
    // Trivial failure if we have just that neighbour
    // Note: If we're removing root as neighbour we might still have a path to it
    if (this.getNeighbours().length < 2) return false;

    // We're not main and we're not removing it, we still have at least one neighbour left
    // if (roomToRemove.id != 1)
    visitedIds = []; // Keep track of what we visit
    visitingStack = [this];
    let firstPass = true;
    while (visitingStack.length > 0) {
        const visitor = visitingStack.pop();
        visitedIds.push(visitor.id);

        // Success condition
        if (visitor.isMain) return true;

        // No success - fetch more
        for (const neighbourKey in visitor.neighbours) {
            const neighbour = visitor.neighbours[neighbourKey];
            if (neighbour === null || (firstPass && neighbour.id === roomToRemove.id))
                continue;
            // Non null, not already visited and is connected by a door.
            if (!visitedIds.includes(neighbour.id) && visitor.wallsType[neighbourKey] === Room.WALL_TYPE.DOOR)
                visitingStack.push(neighbour);
        }
    }

    // We exhausted neighbours without success - exit on failure
    return false;
}

/** Returns true if a neighbour west or east are binding this room's breadth */
Room.prototype.clampedBreadth = function () {
    return (this.neighbours['west'] !== null || this.neighbours['east'] !== null) || // Attached
        (this.neighbours['north'] !== null && this.neighbours['south'] !== null); // Sandwiched
}

/** Returns true if a neighbour north or south are binding this room's width */
Room.prototype.clampedWidth = function () {
    return (this.neighbours['north'] !== null || this.neighbours['south'] !== null) || // Attached
        (this.neighbours['west'] !== null && this.neighbours['east'] !== null); // Sandwiched
}
